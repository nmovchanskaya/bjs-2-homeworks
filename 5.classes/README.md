# Домашнее задание к лекции 5 «Классы»

## Задача №1. Печатное издание

Задача продолжает идеи, заложенные в предыдущем ДЗ, на этот раз с использованием всей мощи классов. Мы помогаем перевести небольшую районную библиотеку в современный цифровой формат. Начнём с того, что реализуем несколько классов: классы печатных изданий (книг, журналов) и класс самой библиотеки, который позволит работать с печатными изданиями (хранить их, выдавать читателям, принимать обратно).

### Процесс реализации

Печатные издания бывают различных типов, но между всеми книгами, сборниками и журналами есть много общего: все они имеют название, год издания, состоят из скольких-то страниц, а ещё могут портиться, пока люди ими пользуются.

1. Создайте базовый класс `PrintEditionItem` со следующими свойствами:

   - `name`
   - `releaseDate`
   - `pagesCount`
   - `state`
   - `type`

   Конструктор класса должен принимать название (`name`), дату выпуска (`releaseDate`) и количество страниц (`pagesCount`) в качестве аргумента. Состояние (`state`) по умолчанию должно устанавливаться равным `100`, тип `type` пока должен быть равен `null`.

2. Испорченное издание можно подклеить и тем самым улучшить его состояние. Создайте метод `fix()`, увеличивающий `state` в полтора раза. Метод не должен принимать аргументов.

3. Нельзя улучшить новое издание, и бесполезно подклеивать полностью уничтоженное. Для лучшего контроля над состоянием создайте «сеттер» для свойства `state`, принимающий в качестве аргумента новое состояние печатного издания (число).

   Если новое состояние меньше `0`, «сеттер» должен записать в свойство `state` значение `0`. Если новое состояние больше `100`, должно быть записано значение `100`. В остальных случаях в свойство `state` должно быть записано переданное в «сеттер» значение.

4. Создайте «геттер», который позволит читать значение свойства `state`.

_Пример использования_

```js
const sherlock = new PrintEditionItem(
  "Полное собрание повестей и рассказов о Шерлоке Холмсе в одном томе",
  2019,
  1008
);

console.log(sherlock.releaseDate); //2019
console.log(sherlock.state); //100
sherlock.fix();
console.log(sherlock.state); //100
```

5. Создайте класс `Magazine`, который будет наследоваться от класса `PrintEditionItem`. Конструктор класса должен принимать такие же параметры, как и класс-родитель. От базового печатного издания журнал отличается только явно указанным типом. Значение свойства `type` должно быть равно `"magazine"`.

6. Создайте класс `Book`, наследующийся от класса `PrintEditionItem`. Конструктор класса должен принимать такие же параметры, как и класс-родитель, а также имя автора книги `author`. Значение свойства `type` должно быть равно `"book"`.

7. Создайте классы `NovelBook` для романов, `FantasticBook` для фантастических произведений и `DetectiveBook` для детективов, наследующиеся от класса `Book`. Значения свойства `type` должны быть равны `"novel"`, `"fantastic"` и `"detective"` соответственно.

_Пример использования_

```js
const picknick = new FantasticBook(
  "Аркадий и Борис Стругацкие",
  "Пикник на обочине",
  1972,
  168
);

console.log(picknick.author); //"Аркадий и Борис Стругацкие"
picknick.state = 10;
console.log(picknick.state); //10
picknick.fix();
console.log(picknick.state); //15
```

## Задача №2. Библиотека

Теперь с помощью классов можно описать все возможные печатные издания, которые бывают в библиотеке. Пришло время подготовить саму библиотеку к работе в цифровом режиме: нужно реализовать возможности хранить книги, выдавать их читателям и принимать обратно.

### Процесс реализации

1. Создайте класс `Library` со следующими свойствами:

   - `name`
   - `books`

   Конструктор класса должен принимать название библиотеки `name` (строка). Значением свойства `books` должен быть пустой массив.

2. Реализуйте метод `addBook(book)`, который будет в качестве аргумента принимать объект (книгу или журнал). Метод должен добавлять книгу в хранилище `books`, только если состояние `state` книги больше `30`.

3. Создайте метод `findBookBy(type, value)`, который в качестве аргументов будет принимать ключ, по которому будет производиться поиск (тип, автор, название, год выпуска и пр.) и искомое значение. Метод должен возвращать книгу в случае успеха и `null`, если запрошенная книга не была найдена.

4. Создайте метод `giveBookByName(bookName)`, который будет в качестве аргумента принимать название книги, запрошенной читателем. Если запрошенная книга найдена, метод должен удалять книгу из хранилища `books`, и возвращать её. Если книга не была найдена, метод должен возвращать `null`.

_Пример использования_

```js
const library = new Library("Библиотека имени Ленина");

library.addBook(
  new DetectiveBook(
    "Артур Конан Дойл",
    "Полное собрание повестей и рассказов о Шерлоке Холмсе в одном томе",
    2019,
    1008
  )
);
library.addBook(
  new FantasticBook(
    "Аркадий и Борис Стругацкие",
    "Пикник на обочине",
    1972,
    168
  )
);
library.addBook(new NovelBook("Герберт Уэллс", "Машина времени", 1895, 138));
library.addBook(new Magazine("Мурзилка", 1924, 60));

console.log(library.findBookBy("name", "Властелин колец")); //null
console.log(library.findBookBy("releaseDate", 1924).name); //"Мурзилка"

console.log("Количество книг до выдачи: " + library.books.length); //Количество книг до выдачи: 4
library.giveBookByName("Машина времени");
console.log("Количество книг после выдачи: " + library.books.length); //Количество книг после выдачи: 3
```

5. Протестируйте корректность работы классов и методов, реализовав тестовый сценарий:
   - Создайте библиотеку;
   - Добавьте в библиотеку несколько печатных изданий различных типов;
   - Найдите книгу, изданную в 1919 году (создайте такую книгу при необходимости);
   - Выдайте любую книгу;
   - Испортите выданную книгу;
   - Почините выданную книгу;
   - Попытайтесь добавить починенную книгу обратно в библиотеку.

## Задача №3. Журнал успеваемости

> Это задача со "звездочкой", ее выполнение не влияет на получение допуска до дипломной работы, но принесет много полезного опыта.

Мы продолжаем совершенствовать журнал успеваемости студентов. Нам предстоит преобразовать код прошлого ДЗ к классам. Реализуйте следующие возможности:

1. В конструкторе класса сохраняйте имя пользователя и создавайте свойство для хранения оценок.
<details>
  <summary>В какой структурой хранить оценки по разнцм предметем</summary>
    Удобней всего хранить оценки ввиде объекта, где свойством будет название предмета, а значением свойства будет массив оценок (по этому предмету). Соответственно, начальным значением будет пустой объект.

    {
      "физика": [4, 5, 5, 4],
      "химия": [3, 4],
      "литература": [4],
      "ифнорматика": [5, 5, 5]
    }
</details>

2. Метод `addMark`, который будет добавлять оценку по предмету:
    1. Валидируйте оценку. Она должна быть не меньше 2 и не больше 5. Если значение уходит за пределы этого диапазона, то оценка не должна добавться. Следовательно, метод следует завершать.
    2. Проверьте наличие предмета. Если предмет отсутствует в свойстве `marks`, то добавляйте новое свойство (названием которого будет название предмета), а значением пустой массив.
    3. Добавляйте в массив оценок (по переданному свойству) новый элемент (который был получен аргументом метода).
3. Метод `getAverageBySubject`, который будет возвращать среднюю оценку по одному предмету:
    1. Проверьте наличие предмета среди оценок. Если предмет отсутствует, то сразу возвращайте ноль.
    2. С помощью `reduce` посчитайте сумму оценок по одному предмету
    3. Возвращайте результат деления суммы оценок на их количество.
4. Метод `getAverage`, который будет возвращать общую среднюю оценку по всем предметам:
    1. Используйте метод `Object.values` для получения всех значений (массив массивов) с оценками.
    2. Для избавления от вложенных массивов и преобразования в один массив со всеми элементами, используйте метод [flat](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat).
    3. Добавьте проверку наличия оценок. Если оценок у студента вообще нет, то возвращайте ноль.
    4. С помощью `reduce` посчитайте сумму всех оценок студента
    5. Возвращайте результат деления суммы оценок на их количество.

Для решения задания, и это представляет наибольшую сложность, вам предстоит придумать структуру данных для хранения оценок по предметам. Работать это должно следующим образом:

### Пример

```js
class Student {
  // ваш код
}

const student = new Student("Олег Никифоров");
student.addMark(5, "химия");
student.addMark(5, "химия");
student.addMark(5, "физика");
student.addMark(4, "физика");
student.addMark(6, "физика"); // Оценка не добавится, так как больше 5
student.getAverageBySubject("физика"); // Средний балл по предмету физика 4.5
student.getAverageBySubject("биология"); // Вернёт 0, так как по такому предмету нет никаких оценок.
student.getAverage(); // Средний балл по всем предметам 4.75
```

### Критерии выполнения

- Реализованы все методы, в каждом из которых вы привели примеры работы исключительных случаев (неверный формат оценки, несуществующий предмет и т.д);
- Возможно добавление оценки по любому предмету.

## Результат при правильной реалиации основного задания
![графическое представление](../Jasmine/results/sucessed_tasks_5.png)

## Результат при правильной реалиации дополнительного задания
![графическое представление](../Jasmine/results/sucessed_tasks_5_1.png)

## Требования для выполнения домашней работы

* Все тесты успешно выполняются.
* Соблюдается [кодстайл](https://github.com/netology-code/codestyle/tree/master/js#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BE%D1%84%D0%BE%D1%80%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-javascript-%D0%BA%D0%BE%D0%B4%D0%B0).
* Решение загружено в форкнутый репозиторий гитхаб.
* Решение опубликовано в github-pages.

## Решение задач
**1.** Откройте файл `task.js` в вашем редакторе кода и выполните задание. <br>
**2.** Проверьте правильность соблюдения [кодстайла](https://github.com/netology-code/codestyle/tree/master/js#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BE%D1%84%D0%BE%D1%80%D0%BC%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-javascript-%D0%BA%D0%BE%D0%B4%D0%B0).
**3.** Вы **можете** написать функцию `testCase` в которой проверять решение вашей работы. <br>
**4.** Откройте файл `test-runer.html` в вашем браузере и убедитесь, что все тесты выполняются. <br>
**5.** Добавьте файл `task.js` в индекс `git` с помощью команды `git add %file-path%`, где `%file-path%` - путь до целевого файла `git add ./5.classes/task.js`. <br>
**6.** Сделайте коммит, используя команду `git commit -m '%comment%'`, где `%comment%` - это произвольный комментарий к вашему коммиту `git commit -m 'Пятое задание полностью готово'`. <br>
**7.** Опубликуйте код в репозиторий `homeworks` с помощью команды `git push -u origin main`.<br>
**8.** Пришлите ссылку на репозиторий через личный кабинет на сайте [Нетологии](https://netology.ru/).<br>
**9.** Пришлите ссылку на страницу github-pages (на страницу с автотестами: `https://%USERNAME%.github.io/bjs-2-homeworks/5.classes/index`)

**_Никаких файлов прикреплять не нужно._**

Все задачи обязательны к выполнению для получения зачета. Присылать на проверку можно каждую задачу по отдельности или все задачи вместе. Во время проверки по частям ваша домашняя работа будет со статусом "На доработке".

Любые вопросы по решению задач задавайте в чате учебной группы.
